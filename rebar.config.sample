%% -*- mode: erlang;erlang-indent-level: 4;indent-tabs-mode: nil -*-
%% ex: ts=4 sw=4 ft=erlang et
%% This is a sample rebar.conf file that shows examples of some of rebar's
%% options.

%% == Core ==

%% Additional library directories to add to the code path
{lib_dirs, []}.

%% Command to run before compiling
{compile_pre_script, "./script.sh"}.

%% Command to run after compiling
{compile_post_script, "./script.sh"}.

%% Command to run before cleaning
{clean_pre_script, "./script.sh"}.

%% Command to run after cleaning
{clean_post_script, "./script.sh"}.

%% == Erlang Compiler ==

%% Erlang files to compile before the rest. Rebar automatically compiles
%% parse_transforms and custom behaviours before anything other than the files
%% in this list.
{erl_first_files, ["mymib1", "mymib2"]}.

%% Erlang compiler options
{erl_opts, [{i, "myinclude"}, {src_dirs, ["src1", "src2"]},
            {platform_define,
            "(linux|solaris|freebsd|darwin)", 'HAVE_SENDFILE'},
            {platform_define, "(linux|freebsd)", 'BACKLOG', 128},
            {platform_define, "R13", 'old_inets'}]}.

%% MIB Options?
{mib_opts, []}.

%% SNMP mibs to compile first?
{mib_first_files, []}.

%% == EDoc ==

%% EDoc options
{edoc_opts, []}.

%% == Port Compiler ==

%% List and wildcard list of files to be compiled. Default is `"c_src/*.c"'
{port_sources, []}.

%% Port compilation environment variables. See rebar_port_compiler.erl for
%% more info. Default is `[]'
{port_envs, []}.

%% Tuple which specifies a pre-compilation script to run, and a filename that
%% exists as a result of the script running.
{port_pre_script, {"script.sh", "skipfile"}}.

%% String that specifies a script to run during cleanup. Use this to remove
%% files/directories created by port_pre_script.
{port_cleanup_script, "cleanup.sh"}.

%% Custom name of the port driver .so file. Defaults to `<Application>_drv.so'.
{so_name, "driver.so"}.

%% == LFE Compiler ==

%% LFE files to compile before the rest
{lfe_first_files, []}.

%% Options for the LFE compiler
{lfe_opts, []}.

%% == ErlyDTL Compiler ==

%% Options for the ErlyDTL compiler
{erlydtl_opts, []}.

%% == EUnit ==

%% Options for eunit:test()
{eunit_opts, []}.

%% Additional compile options for eunit. erl_opts from above is also used
{eunit_compile_opts, []}.

%% Same as erl_first_files, but used only when running 'eunit'
{eunit_first_files, []}.

%% Whether to enable coverage reporting. Default is `false'
{cover_enabled, false}.

%% Whether to print coverage report to console. Default is `false'
{cover_print_enabled, false}.

%% == Dialyzer ==

%% Options for running dialyzer
%% {plt, PltFile}
%% 'src': run Dialyzer on the source files as in 'dialyzer --src'
%% {warnings, [WarnOpts]}: turn on/off Dialyzer warnings
{dialyzer_opts, [{plt, PltFile}, {warnings, [WarnOpts]}, src]}.

%% == Cleanup ==

%% Which files to cleanup
{clean_files, ["file", "file2"]}.

%% == Reltool ==

%% Target directory for the release
{target, "target"}.

%% == OTP Applications ==

%% Binaries to link into the erlang path?
{app_bin, []}.

%% Enable validation of the OTP app module list. Default is 'true'
{validate_app_modules, true}.

%% == Dependancies ==

%% Where to put any downloaded depandencies. Default is `deps'
{deps_dir, ["deps"]}.

%% What dependancies we have, depandencies can be of 3 forms, an application
%% name as an atom, eg. mochiweb, a name and a version (from the .app file), or
%% an application name, a version and the SCM details on how to fetch it (SCM
%% type, location and revision). Rebar currently support git, hg, bzr and svn.
{deps, [application_name,
        {application_name, "1.0.*"},
        {application_name, "1.0.*", {hg, "http://bitbucket.org/basho/rebar/", "f3626d5858a6"}}]}.

%% == Subdirectories ==

%% Subdirectories?
{sub_dirs, ["dir1", "dir2"]}.

%% == Pre/Post Command Hooks ==

%% pre and post commands can be assigned to any command
{pre_clean, "make preclean"}.

{post_clean, "touch postclean.out"}.
{post_generate, "touch postgenerate.out"}.

%% pre and post commands can also be tied to the execution of specific modules
%% allowing for more fine grained control, at the expense of having to know
%% the names of the modules that are executing (NB: minus the "rebar_" prefix).

{pre_compile,
    [{otp_app, "./prepare_package_files.sh"},
     {erlc_compiler, "escript generate_headers"},
     {abnfc_compiler, "touch precompile.abnfc.out"},
     {lfe_compiler, "touch precompile.lfe.out"},
     {asn1_compiler, "touch precompile.asn1.out"},
     {neotoma_compiler, "touch precompile.neotoma.out"},
     {port_compiler, "echo $DRV_LDFLAGS >> precompile.port.out"}]}.

{post_compile,
    [{otp_app, "touch postcompile.otp_app.out"},
     {erlc_compiler, "touch postcompile.erlc.out"},
     {abnfc_compiler, "touch postcompile.abnfc.out"},
     {lfe_compiler, "touch postcompile.lfe.out"},
     {asn1_compiler, "touch postcompile.asn1.out"},
     {neotoma_compiler, "touch postcompile.neotoma.out"},
     {port_compiler, "echo $DRV_LDFLAGS >> postcompile.port.out"}]}.
